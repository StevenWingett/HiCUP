#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use FindBin '$Bin';
use lib "$Bin/../";
use hicup_module;

###################################################################################
###################################################################################
##This file is Copyright (C) 2020, Steven Wingett (steven.wingett@babraham.ac.uk)##
##                                                                               ##
##                                                                               ##
##This file is part of HiCUP.                                                    ##
##                                                                               ##
##HiCUP is free software: you can redistribute it and/or modify                  ##
##it under the terms of the GNU General Public License as published by           ##
##the Free Software Foundation, either version 3 of the License, or              ##
##(at your option) any later version.                                            ##
##                                                                               ##
##HiCUP is distributed in the hope that it will be useful,                       ##
##but WITHOUT ANY WARRANTY; without even the implied warranty of                 ##
##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                  ##
##GNU General Public License for more details.                                   ##
##                                                                               ##
##You should have received a copy of the GNU General Public License              ##
##along with HiCUP.  If not, see <http://www.gnu.org/licenses/>.                 ##
###################################################################################
###################################################################################


##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
  help            => '',
  version => '',
  zip => ''
);


my $config_result = GetOptions(
    "help"        => \$config{help},
    "version"     => \$config{version},
	"zip" => \$config{zip}
);
die "Could not parse options.\n" unless ($config_result);


if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}

if ( $config{version} ) {    #Print version and exit
    print "hicup2juicebox v$hicup_module::VERSION\n";
    exit(0);
}

unless(@ARGV){
    print while (<DATA>);
    exit(0);
}


##########################################################
#Parse data
my @files = @ARGV;    #Pass file names as command-line arguments
foreach my $file (@files){
  
  chomp $file;
  print "Processing $file\n";
  
  if ($file =~ /\.gz$/){
    open (IN,"gunzip -c $file |") or die "Couldn't read $file : $!";  
  }
  elsif ($file =~ /\.bam$/) {
    open (IN,"samtools view $file |") or die "Couldn't read $file: $!";
  }
  else{
    open (IN, $file) or die "Could not open $file\n";
  }
  
  my $outfile = "$file.prejuicer";
  if($config{zip}){
	$outfile .= '.gz';
	open(OUT, "| gzip -c - > $outfile") or die "Could not write to '$outfile' : $!";
  }else{
	open (OUT, '>', $outfile) or die "Could not write to '$outfile'\n";
  }
  

  
  my %grouped_ditags_blocs;
  
  while(<IN>){
	next if(/^@/);   #Remove SAM header lines
    
    my $readF = $_;
    my $readR = scalar <IN>;
	
	my ($chromosomeF, $positionF, $strandF) = get_csome_position($readF);
	my ($chromosomeR, $positionR, $strandR) = get_csome_position($readR);
	
	my $mapqF = (split("\t", $readF))[4];
	my $mapqR = (split("\t", $readR))[4];
	
	my $ditag;
	my $ditag_bloc;
	
	my $labelF = $chromosomeF . '_' . $positionF;
	my $labelR = $chromosomeR . '_' . $positionR;
	
	if( ($labelF cmp $labelR) == 1 ){
		$ditag_bloc = join('_', ($chromosomeR, $chromosomeF, $positionR, $positionF, $strandR, $strandF));
		$ditag = "$strandR\t$chromosomeR\t$positionR\t0\t$strandF\t$chromosomeF\t$positionF\t1\t$mapqR\t$mapqF";
	} else {
		$ditag_bloc = join('_', ($chromosomeF, $chromosomeR, $positionF, $positionR, $strandF, $strandR));
		$ditag = "$strandF\t$chromosomeF\t$positionF\t0\t$strandR\t$chromosomeR\t$positionR\t1\t$mapqF\t$mapqR";
	}
	
	push( @{ $grouped_ditags_blocs{$ditag_bloc} }, $ditag);
	
  }
  
  my $index = 1;
  foreach my $ditags_bloc (sort keys %grouped_ditags_blocs) {
	foreach my $ditag ( @{ $grouped_ditags_blocs{$ditags_bloc} } ){
		print OUT "$index\t$ditag\n";
		$index++;
	}
  }
  
  close IN or die "Could not close filehandle on '$file' : $!";
  close OUT or die "Could not close filehandle on '$outfile' : $!";
}

print "The outputfiles generated by this script may be converted to Juicer '.hic' files using the 'pre' command as described at: https://github.com/aidenlab/juicer/wiki/Pre";

print "\nProcessing complete.\n";

exit (0);




###############################################################################
#Subroutines
###############################################################################

#get_csome_position
#Takes a SAM read and returns the chromosome and the sonication point of the ditag
#and the strand (positive (0) or negative (1))
sub get_csome_position{
        my $read = $_[0];
        
        my $csome = (split(/\t/, $read))[2];
        my $pos = (split(/\t/, $read))[3];
        my $cigar = (split(/\t/, $read))[5];
        my $strand = (split(/\t/, $read))[1];

        unless($strand & 0x10){    #Positive strand
               return ($csome, $pos, 0) 
        }
        
        #Negative strand - process CIGAR string
        my $three_prime = $pos - 1; # need to adjust this only once

        # for InDel free matches we can simply use the M number in the CIGAR string
        if ($cigar =~ /^(\d+)M$/){ # linear match
               $three_prime  += $1;
        }

        # parsing CIGAR string
        my @len = split (/\D+/,$cigar); # storing the length per operation
        my @ops = split (/\d+/,$cigar); # storing the operation
        shift @ops; # remove the empty first element
        die "CIGAR string contained a non-matching number of lengths and operations ($cigar)\n" unless (scalar @len == scalar @ops);

        # warn "CIGAR string; $cigar\n";
        ### determining end position of the read
        foreach my $index(0..$#len){
               if ($ops[$index] eq 'M'){  # standard matching bases
                       $three_prime += $len[$index];
                       # warn "Operation is 'M', adding $len[$index] bp\n";
               }
               elsif($ops[$index] eq 'I'){ # insertions do not affect the end position
                       # warn "Operation is 'I', next\n";
               }
               elsif($ops[$index] eq 'D'){ # deletions do affect the end position
                       # warn "Operation is 'D',adding $len[$index] bp\n";
                       $three_prime += $len[$index];
               }
               else{
                       die "Found CIGAR operations other than M, I or D: '$ops[$index]'. Not allowed at the moment\n";
               }
        }
        
        return ($csome, $three_prime, 1);
}



__DATA__

HiCUP homepage: www.bioinformatics.babraham.ac.uk/projects/hicup

The hicup2juicer script converts HiCUP BAM/SAM files to a format compatible 
with Juicer and JuiceBox( https://github.com/aidenlab/juicer ).
Outputfiles generated by this script may be converted to Juicer ".hic" files 
using the "pre" command as described at: https://github.com/aidenlab/juicer/wiki/Pre

The script does not use restriction site co-ordiantes when generating output.

SYNOPSIS

hiup2juicer [OPTIONS]
hicup2juicer [OPTIONS] [SAM/BAM FILES]...

FUNCTION

HiCUP generates SAM/BAM files of mapped, filtered paired-end reads 
constituting the sequenced valid Hi-C di-tags. These may then be analysed by a 
variety of specialised tools, but before this is possible the datasets will 
need parsing into an appropriate format.

The hicup2juicer script converts HiCUP BAM/SAM files to a tab-delimited format 
comprising 7 columns, with read pairs on the same line:

<readname> <str1> <chr1> <pos1> <frag1> <str2> <chr2> <pos2> <frag2> <mapq1> <mapq2>
str = strand (0 for forward, anything else for reverse)
chr = chromosome (must be a chromosome in the genome)
pos = position
frag = restriction site fragment
mapq = mapping quality score

Column1: Readpair index number (starting at 1)
Column2: forward read strand (0 = positive strand, 1 = negative strand)
Column3: forward read chromosome name
Column4: forward read position
Column5: forward read fragment id (set to the dummy value 0)
Column6: reverse read strand (0 = positive strand, 1 = negative strand)
Column7: reverse read chromosome name
Column8: reverse read position
Column9: reverse read fragment id (set to the dummy value 1)
Column10: forward read MAPQ score
Column11: reverse read MAPQ score


COMMAND LINE OPTIONS

--help         Print help message and exit
--version      Print the program version and exit
--zip          Write output to a gzip file

Full instructions on running the pipeline can be found at:
www.bioinformatics.babraham.ac.uk/projects/hicup

Steven Wingett, Babraham Institute, Cambridge, UK (steven.wingett@babraham.ac.uk)
